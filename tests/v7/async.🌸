import std

read_file : (path: Text) -> Text, IO = external

Async := <A>() -> A, IO


concurrent := (left: Coro, right: Coro) -> {
	left_result := None
	right_result := None
	loop {
		if left_result == None {
			match left.next {
				Done::[result] -> left_result = result
				Effect::[effect] -> raise effect
			}
		}
		if right_result == None {
			match right.next {
				Done::[result] -> right_result = result
				Effect::[effect] -> raise effect
			}
		}
		if left_result <> None and right_result <> None {
			return [left_result.value, right_result.value] 
		}
	}
}

concurrent := (spawner) -> {
	; TODO
}

accept_connection : () -> Connection, IO = external
handle_connection : (Connection) -> [], IO = external


spawn := <A, Args...>(f: (Args...) -> ([], Yield<A>), args...: Args...) -> Iter<A> {
	return () -> {
		f(args...)
	}
}

async := <A, Args...>(f: (Args...) -> (A, IO), args...: Args...) -> Coro<IO, A> {
	; Magic?
}


concurrent := <A>(spawner: () -> A, Spawn) -> {

	tasks := List<Coro>::new()
	

	spawner() with {
		Spawn::[task], continue_spawner -> {
			tasks.add(task)
			task() with {
				IO::[job] -> {
					result := raise job
					continue_spawner()
					continues result
				}
			}
		}
		IO::[job] -> 
	}
}

main := () -> {
	; Both reads happen concurrently, so using something like io_uring will make it twice as fast!
	[a, b] := concurrent(read_file.coro("a.txt"), read_file.coro("b.txt"))

	concurrent(() -> {
		; Starts a server on localhost:8080, this is a blocking call
		server := start_server("localhost", 8080)

		; Waits for a connection and exits the loop when the server is closed
		for connection in server.accept_connections() {
			; Spawns a new async task, that will be executed concurrently from the others
			; We don not care about the resut, so we do not take a handle to it
			handle_connection.spawn(collection)
		}
		; In the end, we automatically wait for all the tasks to finish
	})
	
	[a, b, c, d] := concurrent(() -> {
		; Spawns a bunch of tasks and keeps handles to them
		a_task := read_file.spawn("a.txt")
		b_task := read_file.spawn("b.txt")
		c_task := read_file.spawn("c.txt")
		d_task := read_file.spawn("d.txt")

		; Concurrently wait for all of them to be finished and return it
		return [a_task.wait, b_task.wait, c_task.wait, d_task.wait]
	})
	
}